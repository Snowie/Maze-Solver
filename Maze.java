/*
 * Author: Lucas A. Doran
 * Date: 11/27/2013
 * Filename: Maze.java
 * Description: Solves mazes generated by Dr. Szumlanski's solution to program 6
 */

import java.util.*;

//Simple class to represent points in a maze
class Point
{
	int x;
	int y;
	char at;
	
	Point(int x, int y, char at)
	{
		this.at = at;
		this.x = x;
		this.y = y;
	}
}

public class Maze 
{	
	private static boolean [][] visited;
	
	//A recursive DFS solution that requires no adjacency matrix
	private static ArrayList<Point> search(char [][] maze, Point currPos, ArrayList<Point> path)
	{
		//Keep track of where we've been
		visited[currPos.y][currPos.x] = true;
		
		//We have found the exit, return the path with the added node!
		if(maze[currPos.y][currPos.x] == 'e')
		{
			path.add(0, currPos);
			return path;
		}
			
		
		//Above
		if(maze[currPos.y - 1][currPos.x] != '#' && !visited[currPos.y - 1][currPos.x])
		{
			//Get the character above our current position
			char above = maze[currPos.y - 1][currPos.x];
			//Run a recursive call to determine if the path above contains the exit
			path = search(maze, new Point(currPos.x, currPos.y - 1, above), path);

			//If our path isn't empty...
			if(!path.isEmpty())
			{
				//Add the current node to the front of the path, we have found the exit!
				path.add(0, currPos);
				return path;
			}
		}
		
		//Below
		if(maze[currPos.y + 1][currPos.x] != '#'  && !visited[currPos.y + 1][currPos.x])
		{
			//Get the character below our current position
			char below = maze[currPos.y + 1][currPos.x];
			//Run a recursive call to determine if the path below contains the exit
			path = search(maze, new Point(currPos.x, currPos.y + 1, below), path);
			
			//If our path isn't empty...
			if(!path.isEmpty())
			{
				//Add the current node to the front of the path, we have found the exit!
				path.add(0, currPos);
				return path;
			}
		}
		
		//Right
		if(maze[currPos.y][currPos.x + 1] != '#'  && !visited[currPos.y][currPos.x + 1])
		{
			//Get the character to the right of our current position
			char right = maze[currPos.y][currPos.x + 1];
			//Run a recursive call to determine if the path to the right contains the exit
			path = search(maze, new Point(currPos.x + 1, currPos.y, right), path);

			//If our path isn't empty...
			if(!path.isEmpty())
			{
				//Add the current node to the front of the path, we have found the exit!
				path.add(0, currPos);
				return path;
			}
		}
		
		//Left
		if(maze[currPos.y][currPos.x - 1] != '#'  && !visited[currPos.y][currPos.x - 1])
		{
			//Get the character to the left of our current position
			char left = maze[currPos.y][currPos.x - 1];
			//Run a recursive call to determine if the path to the left contains the exit
			path = search(maze, new Point(currPos.x - 1, currPos.y, left), path);
			
			//If our path isn't empty...
			if(!path.isEmpty())
			{
				//Add the current node to the front of the path, we have found the exit!
				path.add(0, currPos);
				return path;
			}
		}
		
		//We aren't at the point and all of our searching has yielded us nothing, return the path without the current position
		return path;
	}
	
	public static void solve(char [][] maze)
	{
		//Initialize a visited array to keep track of where we've been
		visited = new boolean[maze.length][maze[0].length];
		
		//Run a recursive DFS to find the path we need
		ArrayList<Point> toCheck = search(maze, new Point(1, 1, maze[1][1]), new ArrayList<Point>());
		
		//Put periods in the path but not at 's' or 'e'
		for(int i = 1; i < toCheck.size() - 1; ++i)
		{
			Point workingPoint = toCheck.get(i);
			maze[workingPoint.y][workingPoint.x] = '.';
		}
	}
	
	public static double difficultyRating()
	{
		return 2.5;
	}
	
	public static double hoursSpent()
	{
		return 1.5;
	}
}
